// DDLC port to Geometry Dash by bombie

/*

                DISCLAIMER!!!

This is a Doki Doki Literature Club fan game that is
not affiliated with Team Salvato. It is designed to be played
only after the official game has been completed.
You can download Doki Doki Literature Club at: http://ddlc.moe

*/



// CONFIG

lines = $.readfile("./ddlc-decompiled/scripts.rpa/script-ch0.rpy").split("\r\n")

_PINK_COLOR = ?c
_DARK_PINK_COLOR = ?c
_HALF_OPACITY_WHITE_COLOR = ?c
_RED_COLOR = 4c // this needs to be static in order for image cache to work
// but these need to be static cause i set them in game :rofl:
_DIALOG_COLOR = 2c
_OUTLINE_COLOR = 3c
_CIRCLE_COLOR = 5c

PLAYER_NAME = "Player"
LEVEL_DURATION = 10 * 60 // seconds

LABELS_EXCLUSION_LIST = ["ch0_kill"]

GENERATE_IMAGES = true
// caching may be unstable if you modify the code (it may cause the level to be *literally* unplayable)
// or hide some objects for some reason i dont really understand :(
CACHE_IMAGES = true
READ_CACHED_IMAGES = true // disable this if you dont have a file named "./cached_output.txt" that you didnt make
// which files to exclude from being read from the cache (theyre still gonna be written)
CACHE_EXCLUDED_IMAGES = []

// END OF CONFIG







// DO NOT EDIT ANYTHING BELOW UNLESS YOU KNOW WHAT YOU'RE DOING

gs = import gamescene
sprites = import "sprites.spwn"
extract obj_props

_PINK_COLOR.set(rgb8(255, 230, 244))
_DARK_PINK_COLOR.set(rgb8(255, 189, 225))
_RED_COLOR.set(rgb8(255, 0, 0))
_HALF_OPACITY_WHITE_COLOR.set(rgb(1, 1, 1, 0.5))

_TEXT_GROUP = ?g
_WIPE_SCENE_GROUP = ?g
_NAME_HOLDER_GROUP = ?g
_INVISIBLE_GROUP = ?g
let _TEXT_SECTION_GROUPS = [?g]
let _TEXT_WORD_GROUPS = []

// these are static because of the image caching thing
_BACKGROUNDS_GROUP = 1g
_SCENE_GROUP = 2g
_IMAGE_OUTLINE_GROUP = 3g
_SPLASH_GROUPS = [4g, ?g]
_MAIN_MENU_GROUPS = [?g, 5g, 6g, ?g, ?g, ?g]
_MAIN_MENU_GIRLS_GROUPS = [7g, 8g, 9g, 10g]
_ANTI_NSFW_BYPASS_GROUPS = [99g, 98g, 97g, 96g]
let _BG_GROUPS = []

_CREDITS_MENU_GROUP = ?g
_BLACK_MASK_GROUP = ?g
_MAIN_MENU_BUTTON_GROUPS = [?g, ?g, ?g]
_WHITE_BG_GROUPS = [?g, ?g, ?g, ?g]
_CLICK_OVERLAY_FEEDBACK_GROUP = [?g, ?g]
_END_SCREEN_GROUPS = [?g, ?g, ?g, ?g]

_FOCUS_OVERLAY_GROUP = ?g
_MAIN_MENU_TUTORIAL_GROUP = ?g

PLAYER_SPEED = 8.3705 // slow speed
TAB_SIZE = 4

sprite_pos_start = {l_pos: 0, r_pos: 0, head_pos: 0, char_pos: 0}

// using manual groups because of the caching system lmfao
let CHARACTERS = {
    narrator: { name: "", },
    s: { name: "???", pos: {x: 90, y: 50}, group: 11g, visible: false, 
        head_group: 12g, l_group: 13g, r_group: 14g, char_group: 15g, sprite_pos: sprite_pos_start, added_sprites: [], },
    m: { name: "Girl 3", pos: {x: 90, y: 50}, group: 21g, visible: false, 
        head_group: 22g, l_group: 23g, r_group: 24g, char_group: 25g, sprite_pos: sprite_pos_start, added_sprites: [], },
    n: { name: "Girl 2", pos: {x: 90, y: 50}, group: 31g, visible: false, 
        head_group: 32g, l_group: 33g, r_group: 34g, char_group: 35g, sprite_pos: sprite_pos_start, added_sprites: [], },
    y: { name: "Girl 1", pos: {x: 90, y: 50}, group: 41g, visible: false, 
        head_group: 42g, l_group: 43g, r_group: 44g, char_group: 45g, sprite_pos: sprite_pos_start, added_sprites: [], },
    ny: { name: "Nat & Yuri", },
    mc: { name:  PLAYER_NAME, },
}

TEXT_CHAR_SIZE_LIST = {
    '0': 13.5, '1': 13.25, '2': 9.5, '3': 13.5, '4': 13.25, '5': 12.5, '6': 14.25, '7': 13.75, '8': 14.25, '9': 12.75, 
    'q': 13.5, 'w': 15, 'e': 16.75, 'r': 12.25, 't': 12.5, 'y': 14.5, 'u': 10.75, 'i': 9.5, 'o': 8.75, 'p': 11, 
    'a': 12.25, 's': 12.5, 'd': 12, 'f': 12.75, 'g': 12, 'h': 11.75, 'j': 11.75, 'k': 8.25, 'l': 8.75, 'z': 12.75, 
    'x': 17.25, 'c': 14.5, 'v': 13.75, 'b': 14.25, 'n': 12, 'm': 17.5, ',': 13.5, '.': 5, '+': 8.5, '-': 12, 
    '!': 10.25, '$': 10, '=': 9.25, '[': 14.5, ']': 16.5, '(': 13.5, ')': 10.75, '<': 13.75, '>': 15, '{': 15, 
    '}': 12.25, "'": 7.75, '"': 6.75, ':': 8.25, ';': 5.5, '?': 8.75, '&': 10.5, '*': 12.25, '^': 12.25, '%': 16.25, 
    'Q': 11.75, 'W': 18, 'E': 16.75, 'R': 13.5, 'T': 15, 'Y': 13.5, 'U': 14.75, 'I': 11, 'O': 10.5, 'P': 15, 
    'A': 15, 'S': 15.25, 'D': 14.5, 'F': 12.5, 'G': 13, 'H': 13.25, 'J': 13.5, 'K': 12.75, 'L': 14, 'Z': 17.25, 
    'X': 17.75, 'C': 16.75, 'V': 15, 'B': 14, 'N': 12.5, 'M': 17.25, '|': 9.5, ' ': 6.5, '\\': 14.75, '~': 9.5, 
    '/': 18, '`': 9.5, 
}

MAIN_CHARACTERS_KEYS = ["s", "m", "n", "y"]
CHARACTERS_TOKENS = ["narrator", "s", "m", "n", "y", "ny", "mc"]
CHARACTERS_NAMES = [" *empty* ", "Sayori", "Yuri", "Monika", "Natsuki", "Nat & Yuri", PLAYER_NAME]
BACKGROUNDS = ["residential_day", "class_day", "club_day", "corridor"]
BACKGROUND_FILE_NAMES = ["bg/residential.png", "bg/class.png", "bg/club.png", "bg/corridor.png"]

WITH_TOKEN_WAIT_TIMES = {"wipeleft_scene": 1, "wipeleft": 0.2}

TOKENS = ["scene", CHARACTERS_TOKENS, "$", "show", "hide", "with"].flatten()

let current_character = "your mother"
let current_bg = ""
let words = 0

in_scene_transition_counter = counter(false)
text_typing_animation_active_counter = counter(false)
in_game_counter = counter(false)
in_tutorial_counter = counter(false)
in_main_menu_counter = counter(false)
in_credits_menu_counter = counter(false)

tutorial_closing_counter = counter(false)

// this adds the no fade object and the no bg effect object
$.add(obj{HVS: ";1,1819,2,-29,3,15,36,1,57,1001;1,22,2,-29,3,45,36,1,57,1001"})

let cached_images = {}
let added_images = []
readed_cached_images = $.readfile("./cache_output.txt", "json") if READ_CACHED_IMAGES else {} // misspelled ikik but it makes more sense than "read"
image_output = match GENERATE_IMAGES { ==true: $.readfile("./output.txt", "json") }

image = (file_name: @string, groups: @array, x_off: @number = 0, y_off: @number = 0, z_order: @number = -5, z_layer: @number = -3, draw_outline: @bool = true, size_multi: @number = 1) {
    if GENERATE_IMAGES == false { return }

    if CACHE_IMAGES { let cached_images[file_name] = "" }
    frame_data = image_output[file_name]
    frame_res = frame_data.res
    frame = frame_data.image.reverse() // this is the actual image

    size = (1/(frame_res[0]/10)+0.02) * size_multi

    added_images.push(file_name)
    if READ_CACHED_IMAGES && (readed_cached_images.get(file_name, default=null) != null && !(file_name in CACHE_EXCLUDED_IMAGES)) {
        // we use this to compress the cache lmao, it removes like half of the size without that much of a performance hit so im ok with it 
        $.add(obj{HVS: ";"+readed_cached_images[file_name].replace("\\$", "1,211,24,-3,25,{},32,{},41,1,21,4,57,2.1001.".fmt([z_order, @string(size).substr(0, 5)]))+"1,1,2,-999"})
        cached_images[file_name] += readed_cached_images[file_name]

        $.print(file_name, " added from cache")
        return
    }

    outline = (x: @number, y: @number) {
        left = x - 1
        right = x + 1
        up = y - 1
        down = y + 1
        
        // we only need one of them to be true, then we can draw an outline, this way we save a ton of objs
        // just added so it also checks if the pixel is on the edge and if it is then also return true since anything on the edge needs an outline
        return (x <= 0 || x >= frame_res[0] || y <= 0 || y >= frame_res[1])
            || (left <= 0 || right >= frame_res[0] || up <= 0 || down >= frame_res[1])
            || (frame[y][left] == [] || frame[y][right] == [] || frame[up][x] == [] || frame[down][x] == []) 
    }

    let img_objs_to_cache = ""
    for j in 0..frame_res[0] {
        for i in frame_res[1]..0 {
            if frame[j][i] == [] { continue }
            [h, s, v] = frame[j][i]

            anti_nsfw_bypass = i%2 + (j%2)*2
            anti_nsfw_bypass_x = (5000 + anti_nsfw_bypass * 1000)*3

            can_draw_outline = outline(i, j) if draw_outline else false

            temp_obj = obj{
                OBJ_ID: 211,
                Z_LAYER: z_layer,
                Z_ORDER: z_order,
                SCALING: size,
                HVS_ENABLED: true,
                COLOR: _RED_COLOR,
                GROUPS: [_SCENE_GROUP, _ANTI_NSFW_BYPASS_GROUPS[anti_nsfw_bypass], groups].flatten(),
                HVS: @string(h)+"a"+@string(s/1000)+"a"+@string(v/1000+0.02)+"a0a0",
                X: x_off + i*(30 * (size-0.01)) + anti_nsfw_bypass_x, Y: y_off + j*(30 * (size-0.01)),
            }

            temp_obj.add()

            let outline_obj = ""
            if can_draw_outline {
                outline_obj = obj{
                    OBJ_ID: 211,
                    Z_LAYER: z_layer,
                    Z_ORDER: z_order-1,
                    SCALING: size+0.075,
                    HVS_ENABLED: true,
                    GROUPS: [_SCENE_GROUP, _IMAGE_OUTLINE_GROUP, _ANTI_NSFW_BYPASS_GROUPS[anti_nsfw_bypass], groups].flatten(),
                    HVS: "0a0a-100a0a0", // full black
                    HIGH_DETAIL: true,
                    X: 3000 + x_off + i*(30 * (size-0.01)) + anti_nsfw_bypass_x, // +3000 for the anti-nsfw bypass lmao
                    Y: y_off + j*(30 * (size-0.01)),
                }
                outline_obj.add()
            }

            img_objs_to_cache += @string(temp_obj) + @string(outline_obj)
        }
    }

    cached_images[file_name] = img_objs_to_cache.replace("1,211,24,-3,25,"+@string(z_order)+",32,"+@string(size).substr(0, 5)+",41,1,21,4,57,2.", "$")
    // 1. trim big floats to 3 decimal places 
    // 2. make sure every object has group 1001 (if for some reason the compression doesnt work, basically a fallback)
    cached_images[file_name] = cached_images[file_name].replace("(?<=\\.\\d{3})\\d+", "").replace(",57,", ",57,1001.")
     
    $.print(file_name, " added")
}







generate_line_tokens = (line: @string) {
    splitted_strings = line.split("\"")
    if splitted_strings.length % 2 == 0 { throw "invalid string at line"+@string(lines.find(line)) }

    let tokens = []
    if splitted_strings.length > 1 {
        for i in 0..splitted_strings.length {
            if i % 2 == 1 { // if in string
                tokens.push('"' + splitted_strings[i] + '"')
                continue
            }

            // if not in string
            tokens += splitted_strings[i].split(" ")
        }
    } else {
        tokens = line.split(" ")
    }
    
    // count the amount of spaces at the beggining of the line
    let spaces = 0
    for char in tokens {
        if char != "" { break } // yeah
        spaces ++
    }


    return [tokens.filter(el => el != ""), (spaces / TAB_SIZE).round()]
}


let i = 35-300

// this looks so much cleaner
collectable = (target, offset: @number = 0, activate_group: @bool = true) {
    [x_off, y_off] = [300, 13]
    $.add(obj{
        OBJ_ID: 1614, // collectable id
        X: x_off, Y: y_off + i + offset,
        GROUPS: [_SCENE_GROUP, _TEXT_GROUP, _INVISIBLE_GROUP],
        SCALING: 6,
        TARGET: target,
        PICKUP_MODE: 2, // toggle trigger
        ACTIVATE_GROUP: activate_group,
    })
}


add_section = (x_off: @number = 0, y_off: @number = 0) {    
    collectable(_TEXT_SECTION_GROUPS[-1], activate_group=false)

    _TEXT_SECTION_GROUPS.push(?g)
    $.print("added a section") // $.print("SEX!! 😋😋😋")

    collectable(_TEXT_SECTION_GROUPS[-1])
}


split_into_lines = (str: @string) {
    let lines = [[]]
    let word_sizes = []
    let len = 0

    for word in str.split(" ") {
        words ++

        // because gd renders text no matter where it is so we need to toggle every 16384 chars
        // but 2000 words is good enough
        if words % 2000 == 1999 { add_section(300, 13) }

        let word_size = 0
        for char in word { word_size += TEXT_CHAR_SIZE_LIST[char] }

        if len + (word.length+1) / 2 >= 65 { lines.push([]); len = 0 }
        len += word.length + 1 // +1 because spaces
        lines[-1].push({word: word, size: word_size})
    }
    
    return lines
}


// good code bro
let hide_show_body_parts_functions = {}
for alpha in [0,1] {
    h = ["hide", "show"][alpha]
    let hide_show_body_parts_functions[h] = {}
    for v in MAIN_CHARACTERS_KEYS {
        let hide_show_body_parts_functions[h][v] = {}
        gr = "head,char,r,l".split(",")
        for j in gr {
            let hide_show_body_parts_functions[h][v][j] = !{ CHARACTERS[v][j+"_group"].toggle_off() } if alpha == 0 else !{ CHARACTERS[v][j+"_group"].toggle_on() }
        }
    }
}


// holy shit this is so ugly
let change_sprite_cached_functions = {}
change_sprite = (char, sprite, x_off: @number = 0, y_off: @number = 0) {
    sprite_pos = sprites.positions[char][sprite]
    sprite_img = sprites.images[char][sprite]
    last_sprite_pos = CHARACTERS[char].sprite_pos

    head_img = sprite_img.get("head", null)
    body_img = sprite_img.get("body", null)
    char_img = sprite_img.get("char", null)
    l_img = sprite_img.get("l", null)
    r_img = sprite_img.get("r", null)

    head_pos = sprite_pos.get("head_pos", null)
    char_pos = sprite_pos.get("char_pos", null)
    l_pos = sprite_pos.get("l_pos", null)
    r_pos = sprite_pos.get("r_pos", null)

    last_head_pos = last_sprite_pos.get("head_pos", 0)
    last_char_pos = last_sprite_pos.get("char_pos", 0)
    last_l_pos = last_sprite_pos.get("l_pos", 0)
    last_r_pos = last_sprite_pos.get("r_pos", 0)

    let to_move = [0]*4 // head, l, r, char

    char_index = MAIN_CHARACTERS_KEYS.index(char)
    bypass_offset = (char_index+2) * 3000
    char_z_order = -(3 - char_index)*2 - 5 // 3 - char_index so its reversed


    // text objects are temporary
    if head_pos != null {
        to_move[0] = last_head_pos - head_pos
        
        if head_img != null && !(head_img in CHARACTERS[char].added_sprites) {
            // $.add(obj{ // text
            //     OBJ_ID: 914,
            //     X: 80*3, Y: 150 + head_pos*6+15,
            //     SCALING: 0.5,
            //     GROUPS: [_SCENE_GROUP, CHARACTERS[char].group, CHARACTERS[char].head_group],
            //     DONT_FADE: true,
            //     DONT_ENTER: true,
            //     TEXT: $.b64encode(head_img.split("/")[1]).replace("/", "_").replace("\\+", "-")
            // })

            image(head_img, [CHARACTERS[char].group, CHARACTERS[char].head_group], 150 + bypass_offset, head_pos*6 - 5, char_z_order, -1)
            CHARACTERS[char].added_sprites.push(head_img)
        }
    }
    if body_img != null {
        to_move[1] = last_l_pos - l_pos
        
        if !(body_img in CHARACTERS[char].added_sprites) {
            // $.add(obj{ // text
            //     OBJ_ID: 914,
            //     X: 80*3, Y: 150 + l_pos*6-15,
            //     SCALING: 0.5,
            //     GROUPS: [_SCENE_GROUP, CHARACTERS[char].group, CHARACTERS[char].l_group],
            //     DONT_FADE: true,
            //     DONT_ENTER: true,
            //     TEXT: $.b64encode(body_img.split("/")[1]).replace("/", "_").replace("\\+", "-")
            // })
            
            // special case where natsukis head has a small offset on 3.png and 3b.png
            // without this, natsuki looks "decapitated"
            natsuki_3_off = [18*0.14, 22*0.36] if char == "n" && (body_img == "natsuki/3.png" || body_img == "natsuki/3b.png") else [0, 0]
            image(body_img, [CHARACTERS[char].group, CHARACTERS[char].l_group], 150 + bypass_offset - natsuki_3_off[0], l_pos*6 + natsuki_3_off[1] - 5, char_z_order, -1)
            CHARACTERS[char].added_sprites.push(body_img)
        }
    }
    if char_pos != null {
        to_move[3] = last_char_pos - char_pos
        
        if char_img != null && !(char_img in CHARACTERS[char].added_sprites) {
            // $.add(obj{ // text
            //     OBJ_ID: 914,
            //     X: 80*3, Y: 150 + char_pos*6,
            //     SCALING: 0.5,
            //     GROUPS: [_SCENE_GROUP, CHARACTERS[char].group, CHARACTERS[char].char_group],
            //     DONT_FADE: true,
            //     DONT_ENTER: true,
            //     TEXT: $.b64encode(char_img.split("/")[1]).replace("/", "_").replace("\\+", "-")
            // })
            image(char_img, [CHARACTERS[char].group, CHARACTERS[char].char_group], 150 + bypass_offset, char_pos*6 - 5, char_z_order, -1)
            CHARACTERS[char].added_sprites.push(char_img)
        }
    }
    if l_pos != null {
        to_move[1] = last_l_pos - l_pos
        
        if l_img != null && !(l_img in CHARACTERS[char].added_sprites) {
            // $.add(obj{ // text
            //     OBJ_ID: 914,
            //     X: 80*3-15, Y: 150 + l_pos*6-15,
            //     SCALING: 0.5,
            //     GROUPS: [_SCENE_GROUP, CHARACTERS[char].group, CHARACTERS[char].l_group],
            //     DONT_FADE: true,
            //     DONT_ENTER: true,
            //     TEXT: $.b64encode(l_img.split("/")[1]).replace("/", "_").replace("\\+", "-")
            // })
            image(l_img, [CHARACTERS[char].group, CHARACTERS[char].l_group], 150 + bypass_offset, l_pos*6 - 5, char_z_order, -1)
            CHARACTERS[char].added_sprites.push(l_img)
        }
    }
    if r_pos != null {
        to_move[2] = last_r_pos - r_pos

        if r_img != null && !(r_img in CHARACTERS[char].added_sprites) {
            // $.add(obj{ // text
            //     OBJ_ID: 914,
            //     X: 80*3+15, Y: 150 + r_pos*6-15,
            //     SCALING: 0.5,
            //     GROUPS: [_SCENE_GROUP, CHARACTERS[char].group, CHARACTERS[char].r_group],
            //     DONT_FADE: true,
            //     DONT_ENTER: true,
            //     TEXT: $.b64encode(r_img.split("/")[1]).replace("/", "_").replace("\\+", "-")
            // })
            image(r_img, [CHARACTERS[char].group, CHARACTERS[char].r_group], 150 + bypass_offset, r_pos*6 - 5, char_z_order, -1)
            CHARACTERS[char].added_sprites.push(r_img)
        }
    }

    hide = (str) { collectable(hide_show_body_parts_functions.hide[char][str]) }
    show = (str) { collectable(hide_show_body_parts_functions.show[char][str]) }

    CHARACTERS[char].sprite_pos = { head_pos: last_head_pos, char_pos: last_char_pos, l_pos: last_l_pos, r_pos: last_r_pos }
    if head_pos != null { CHARACTERS[char].sprite_pos.head_pos = head_pos; show("head") } else { hide("head") }
    if char_pos != null { CHARACTERS[char].sprite_pos.char_pos = char_pos; show("char") } else { hide("char") }
    if l_pos != null { CHARACTERS[char].sprite_pos.l_pos = l_pos; show("l") } else { hide("l") }
    if r_pos != null { CHARACTERS[char].sprite_pos.r_pos = r_pos; show("r") } else { hide("r") }


    // add collectable that actually moves the shit up and down weeeeeee :DDD
    move_groups = [CHARACTERS[char].head_group, CHARACTERS[char].l_group, CHARACTERS[char].r_group, CHARACTERS[char].char_group]
    move_group_names = "head_group,l_group,r_group,char_group".split(",")
    to_move_values = to_move

    // $.print(to_move, " \"", sprite, "\"  last: ", last_sprite_pos, "  curr: ", sprite_pos)
    for j in 0..to_move.length {
        if to_move[j] == 0 { continue }

        // this simple thing saves 100 whole groups WHAT
        // sputnix reference
        cache_name = char+"_"+move_group_names[j]+"_"+@string(to_move[j])
        if change_sprite_cached_functions.get(cache_name, null) == null {
            change_sprite_cached_functions[cache_name] = !{ move_groups[j].move(0, to_move[j]*2, 0) }
        }

        collectable(change_sprite_cached_functions[cache_name])
    }
}


crash_func = !{}
gen_crash_triggers = () {
    temp_group_for_crash = ?g
    $.add(obj{
        OBJ_ID: 1268, // spawn trigger id
        X: 66, Y: 66,
        GROUPS: crash_func.start_group,
        SPAWN_TRIGGERED: true,
        MULTI_TRIGGER: true,
        SPAWN_DURATION: 0.1,
        TARGET: temp_group_for_crash,
    })
    $.add(obj{
        OBJ_ID: 1616, // stop trigger
        X: 88, Y: 88,
        TARGET: crash_func.start_group,
        GROUPS: temp_group_for_crash,
        SPAWN_TRIGGERED: true,
        MULTI_TRIGGER: true,
    })
}


say_character = (command, tokens, x_off: @number = 0, y_off: @number = 0, speaker_x_off: @number = 0, speaker_y_off: @number = 0) {
    i+=300

    if tokens.length == 2 { change_sprite(command, tokens[0], x_off, y_off) }

    if current_character == "narrator" { // checks if the last character was the narrator
        // if it was, make the name holder thingy appear
        collectable(_NAME_HOLDER_GROUP)
    }

    
    // we do this for the typing animation
    _lines = split_into_lines(tokens[-1].replace("\\[player\\]", PLAYER_NAME).replace("\\{([^}]+)\\}", "").replace("%%", "%"))
    scale = 0.55
    space_size = TEXT_CHAR_SIZE_LIST[" "]

    let y = 60
    let iter = 0
    for line in _lines {
        let last_size = 0
        let last_pos = -380

        let word_iter = 0
        for word in line {
            word_iter ++
            iter ++
            if iter > _TEXT_WORD_GROUPS.length { _TEXT_WORD_GROUPS.push(?g) }

            $.add(obj{ // text
                OBJ_ID: 914,
                X: x_off + (last_pos + last_size/2 + space_size + word.size/2)*scale,
                Y: y_off + i + y/2,
                SCALING: scale,
                GROUPS: [_TEXT_GROUP, _SCENE_GROUP, _TEXT_SECTION_GROUPS[-1], _TEXT_WORD_GROUPS[iter-1]],
                DONT_FADE: true,
                DONT_ENTER: true,
                TEXT: $.b64encode(word.word.replace("\\{([^}]+)\\}", "").replace("%%", "%")).replace("/", "_").replace("\\+", "-")
            })
            last_pos = last_pos + last_size/2 + space_size + word.size/2
            last_size = word.size
        }
        y -= 45
    }
    
    current_character = command
    $.add(obj{ // speaker name
        OBJ_ID: 914,
        X: speaker_x_off, Y: speaker_y_off + i,
        SCALING: 0.55,
        GROUPS: [_TEXT_GROUP, _SCENE_GROUP, _TEXT_SECTION_GROUPS[-1]],
        DONT_FADE: true,
        DONT_ENTER: true,
        TEXT: $.b64encode(CHARACTERS[current_character].name).replace("/", "_").replace("\\+", "-")
    })
}


say_narrator = (command, x_off: @number = 0, y_off: @number = 0) {
    i+=300
    
    if current_character != "narrator" { // checks if the last character was the narrator
        // if it wasnt then make the name holder thingy dissappear
        collectable(_NAME_HOLDER_GROUP, activate_group=false)
    }

    current_character = "narrator"

    // we do this for the typing animation
    _lines = split_into_lines(command.replace('"', "").replace("\\[player\\]", PLAYER_NAME).replace("\\{([^}]+)\\}", "").replace("%%", "%"))
    scale = 0.55
    space_size = TEXT_CHAR_SIZE_LIST[" "]

    let y = 60
    let iter = 0
    for line in _lines {
        let last_size = 0
        let last_pos = -375

        let word_iter = 0
        for word in line {
            word_iter ++
            iter ++
            if iter > _TEXT_WORD_GROUPS.length { _TEXT_WORD_GROUPS.push(?g) }
            
            $.add(obj{ // text
                OBJ_ID: 914,
                X: x_off + (last_pos + last_size/2 + space_size + word.size/2)*scale,
                Y: y_off + i + y/2,
                SCALING: scale,
                GROUPS: [_TEXT_GROUP, _SCENE_GROUP, _TEXT_SECTION_GROUPS[-1], _TEXT_WORD_GROUPS[iter-1]],
                DONT_FADE: true,
                DONT_ENTER: true,
                TEXT: $.b64encode(word.word).replace("/", "_").replace("\\+", "-")
            })
            last_pos = last_pos + last_size/2 + space_size + word.size/2
            last_size = word.size
        }
        y -= 45
    }
    // $.add(obj{ // text
    //     OBJ_ID: 914,
    //     X: x_off, Y: y_off + i,
    //     SCALING: 0.55,
    //     GROUPS: [_TEXT_GROUP, _SCENE_GROUP, _TEXT_SECTION_GROUPS[-1]],
    //     DONT_FADE: true,
    //     DONT_ENTER: true,
    //     TEXT: $.b64encode(split_into_lines(command.replace('"', "").replace("\\[player\\]", PLAYER_NAME).replace("\\{([^}]+)\\}", "").replace("%%", "%"))).replace("/", "_").replace("\\+", "-")
    // })
}

set_bg = (bg_name, next_line, x_off: @number = 0, y_off: @number = 0) {
    if current_bg == bg_name { return } // checks if the last bg is the current bg

    wait_time = WITH_TOKEN_WAIT_TIMES.get(next_line[0][1], default=0) if next_line[0][0] == "with" else 0

    temp_func = !{ -> in_scene_transition_counter ++; -> _TEXT_GROUP.alpha(0, 0.25) } // started transition
    temp_group = temp_func.start_group

    current_bg_idx = BACKGROUNDS.index(current_bg)
    next_bg_idx = BACKGROUNDS.index(bg_name)

    change_bgs = !{
        -> _BG_GROUPS[current_bg_idx].toggle_off()
        -> _BG_GROUPS[next_bg_idx].toggle_on()

        -> _BACKGROUNDS_GROUP.move(0, 200 * current_bg_idx, 0) // move to first bg
        -> _BACKGROUNDS_GROUP.move(0, -200 * next_bg_idx, 0) // move to desired bg
        -> in_scene_transition_counter -- // done transitioning
        -> _TEXT_GROUP.alpha(1, 0)
    } if current_bg_idx != null else !{
        -> _BG_GROUPS[next_bg_idx].toggle_on()

        -> _BACKGROUNDS_GROUP.move(0, -200 * next_bg_idx, 0) // move to desired bg
        -> in_scene_transition_counter -- // done transitioning
        -> _TEXT_GROUP.alpha(1, 0)
    }

    // we have to do wait() manually because of the fucking optimizer :skull:
    $.add(obj{
        OBJ_ID: 1268, // spawn trigger id
        X: 400, Y: 400,
        GROUPS: temp_group,
        SPAWN_TRIGGERED: true,
        SPAWN_DURATION: wait_time,
        TARGET: change_bgs,
    })

    // hide all characters while also hopefully not using too many groups and not breaking the optimizer
    // HOLY SHIT ITS USING 0 GROUPS
    for char in MAIN_CHARACTERS_KEYS {
        if !CHARACTERS[char].visible { continue }
        CHARACTERS[char].visible = false

        $.add(obj{
            OBJ_ID: 1007, // alpha trigger id
            X: 500, Y: 400,
            GROUPS: change_bgs.start_group,
            SPAWN_TRIGGERED: true,
            TARGET: CHARACTERS[char].group,
            DURATION: 0,
            OPACITY: 0,
        })
    }
    // end of hiding all characters

    collectable(temp_func, 300)
    current_bg = bg_name
}


set_scene = (tokens, next_line, x_off: @number = 0, y_off: @number = 0) {
    if tokens[0] == "bg" { // in the first day, tokens[0] is always "bg"
        set_bg(tokens[1], next_line, x_off, y_off)
    }
}



fade_in_bgs_function = !{ // group saving goes brrr
    -> _BACKGROUNDS_GROUP.alpha(1, 0.25)
}

fade_in_scene = (x_off: @number = 0, y_off: @number = 0) {
    collectable(fade_in_bgs_function, 300)
}


create_scene_wiper_thing = (x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 211, // white block
        X: x_off - (9*30)/2, Y: y_off+90,
        GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
        Z_LAYER: 7,
        SCALING: 10,
        HVS: "0a0a-100a0a0", // full black
        HVS_ENABLED: true,
    })

    $.add(obj{
        OBJ_ID: 211, // white block
        X: x_off + (9*30)/2, Y: y_off+90,
        GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
        Z_LAYER: 7,
        SCALING: 10,
        HVS: "0a0a-100a0a0", // full black
        HVS_ENABLED: true,
    })

    // 2 gradients on the left side
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off - (19*30)/2 - (4*30)/2, Y: y_off + i*(6*30),
            ROTATION: -90,
            GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 6,
            Z_LAYER: 7,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    // 2 gradients on the right side
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off + (19*30)/2 + (4*30)/2, Y: y_off + i*(6*30),
            ROTATION: 90,
            GROUPS: [_SCENE_GROUP, _WIPE_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 6,
            Z_LAYER: 7,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


wipe_left_scene_func = !{ // group saving probably
    -> _WIPE_SCENE_GROUP.move(-460, 0, 0) // move behind the player
    -> _WIPE_SCENE_GROUP.move(460, 0, 1.5, EASE_IN) // move it to the right
}
wipe_left_scene = (x_off: @number = 0, y_off: @number = 0) {
    collectable(wipe_left_scene_func, 300)
}

wipe_left = (x_off: @number = 0, y_off: @number = 0) {
    temp_group = ?g

    // we have to do wait() manually because of the fucking optimizer :skull:
    $.add(obj{
        OBJ_ID: 1268, // spawn trigger id
        X: 450, Y: 450,
        GROUPS: temp_group,
        SPAWN_TRIGGERED: true,
        SPAWN_DURATION: 0,
        TARGET: !{
            -> _BACKGROUNDS_GROUP.alpha(0, 0.2) // fade out
        },
    })

    $.add(obj{
        OBJ_ID: 1268, // spawn trigger id
        X: 450, Y: 450,
        GROUPS: temp_group,
        SPAWN_TRIGGERED: true,
        SPAWN_DURATION: 0.2,
        TARGET: fade_in_bgs_function,
    })

    collectable(temp_group, 300)
}


with = (tokens, x_off: @number = 0, y_off: @number = 0) {
    // syncing with the bg happens in the bg change macro
    match tokens[0] {
        =="wipeleft_scene": wipe_left_scene(x_off, y_off),
        =="dissolve_scene_full": fade_in_scene(x_off, y_off),
        =="wipeleft": wipe_left(x_off, y_off), // dont actually wipe left, just fade out and in the bg lmao
    }
}






circle = (x: @number, y: @number, scale: @number, color, groups: @array, z_order: @number) {
    // screw the quarter circle thingies, ive found a better one
    $.add(obj{
        OBJ_ID: 1841, // animated circle
        X: x, Y: y,
        SCALING: scale * 5, // scale 5 is a full editor grid for this object
        COLOR: color,
        GROUPS: [_SCENE_GROUP, groups].flatten(),
        Z_ORDER: z_order,
        Z_LAYER: -3,
        DONT_FADE: true,
        DONT_ENTER: true,
        ANIMATION_SPEED: 0.001, // cant have numbers <0.001 in geometry dash (detroit)
    })
}


line = (x: @number, y: @number, rotation: @number = 0) {
    // for loop because quarter circle outlines are 1.667x bigger than 3d lines  
    // plus i dont really care about usage of objects at this scale lmao
    for i in 0..3 {
        $.add(obj{
            OBJ_ID: 507, // 3d line
            X: x, Y: y + 10 - i*0.75, // +10 because of the 3d line being offset
            ROTATION: rotation,
            COLOR: _OUTLINE_COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 3,
            Z_ORDER: -1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


vertical_line = (x: @number, y: @number, rotation: @number = 90) {
    // for loop because quarter circle outlines are 1.667x bigger than 3d lines  
    // plus i dont really care about usage of objects at this scale lmao
    for i in 0..3 {
        $.add(obj{
            OBJ_ID: 507, // 3d line
            X: x + 20 - i*0.75, Y: y, // +10 because of the 3d line being offset
            ROTATION: rotation,
            COLOR: _OUTLINE_COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 3,
            Z_ORDER: -1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


dialog_box_outline = (x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off, Y: y_off,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        Z_LAYER: 3,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    
    for i in 1..14 {
        line(x_off + i*30, y_off)
    }

    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off + 30*14, Y: y_off,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 90,
        Z_LAYER: 3,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    vertical_line(x_off - 10 + 30*14, y_off - 30)

    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off + 30*14, Y: y_off - 60,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 180,
        Z_LAYER: 3,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 1..14 {
        line(x_off + i*30, y_off - 78.5, 180) // weird y because of 3d obj offset
    }

    $.add(obj{
        OBJ_ID: 1835, // quarter circle outline
        X: x_off, Y: y_off - 60,
        COLOR: _OUTLINE_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: -90,
        Z_LAYER: 3,
        Z_ORDER: -1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
    
    vertical_line(x_off - 28.5, y_off - 30, -90)
}


dialog_box_interior = (x_off: @number = 0, y_off: @number = 0) {
    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off, Y: y_off,
        COLOR: _DIALOG_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 0,
        Z_LAYER: 1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 1..14 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*30, Y: y_off,
            COLOR: _DIALOG_COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off + 30*14, Y: y_off,
        COLOR: _DIALOG_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 90,
        Z_LAYER: 1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 0..14+1 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*30, Y: y_off - 30,
            COLOR: _DIALOG_COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off + 30*14, Y: y_off - 60,
        COLOR: _DIALOG_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: 180,
        Z_LAYER: 1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })

    for i in 1..14 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*30, Y: y_off - 60,
            COLOR: _DIALOG_COLOR,
            GROUPS: _SCENE_GROUP,
            Z_LAYER: 1,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    $.add(obj{
        OBJ_ID: 1837, // quarter circle thingy
        X: x_off, Y: y_off - 60,
        COLOR: _DIALOG_COLOR,
        GROUPS: _SCENE_GROUP,
        ROTATION: -90,
        Z_LAYER: 1,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
}


dialog_box_speaker_thing = (x_off: @number = 0, y_off: @number = 0) {
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 1837, // quarter circle thingy
            X: x_off + i*75, Y: y_off - 22.5,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            COLOR: 1c,
            SCALING: 0.5,
            ROTATION: 90 * i,
            Z_LAYER: 3,
            Z_ORDER: -4,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    for i in 0..4 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + (i+1)*15, Y: y_off - 22.5,
            SCALING: 0.5,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            Z_LAYER: 3,
            Z_ORDER: -4,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }

    for i in 0..6 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + i*15, Y: y_off - 37.5,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            SCALING: 0.5,
            Z_LAYER: 3,
            Z_ORDER: -4,
            DONT_FADE: true,
            DONT_ENTER: true,
        })

        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off + i*15, Y: y_off - 42,
            GROUPS: [_SCENE_GROUP, _NAME_HOLDER_GROUP],
            HVS: "0a0a0.75a0a0", // gray
            HVS_ENABLED: true, 
            SCALING: 0.5,
            Z_LAYER: 3,
            Z_ORDER: -3,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}


generate_dialog_box = () {
    dialog_box_outline(92, 83)
    dialog_box_interior(92, 83)
    dialog_box_speaker_thing(130, 143)

    // // add circle thingies
    // for i in -11..11 { // horizontal
    //     for j in -4..4 { // vertical
    //         circle(300 + i*20 + (j%2+1)*10, j*11, 0.15)
    //     }
    // }
}



generate_borders = (x_off: @number = 0, y_off: @number = 0) {
    // blocks
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off - (18*30)/2 - (6*30)/2 + 5, 
            Y: y_off+180*i,
            GROUPS: [_SCENE_GROUP],
            Z_ORDER: 69,
            SCALING: 6,
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
        })
        $.add(obj{
            OBJ_ID: 211, // white block
            X: x_off + (18*30)/2 + (6*30)/2 - 5, 
            Y: y_off+180*i,
            GROUPS: [_SCENE_GROUP],
            Z_ORDER: 69,
            SCALING: 6,
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
        })
    }

    // 4 gradients each on the left and right side
    for i in 0..4 {
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off - (18*30)/2 + (2.5/3*2)*30/2 + 5, 
            Y: y_off + i*(2.5*30) - 22.5,
            ROTATION: 90,
            GROUPS: [_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 2.5,
            Z_ORDER: 69,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
        $.add(obj{
            OBJ_ID: 503, // gradient thingy
            X: x_off + (18*30)/2 - (2.5/3*2)*30/2 - 5, 
            Y: y_off + i*(2.5*30) - 22.5,
            ROTATION: -90,
            GROUPS: [_SCENE_GROUP],
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 2.5,
            Z_ORDER: 69,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}






// group saves

// dont remove the arrows or the optimizer is gonna fuck everything up
// somehow it works without the arrows anyways so thats nice yk (future bombie here idk if thats true so dont do it)
// reoptimized this, probably dont even need it anymore
// hop_funcs = { // this saves a whole 1 group in day 1 :rofl: (it might save more for the whole act)
//     s: !{ -> CHARACTERS.s.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.s.group.move(0, -10, 0.2, EASE_IN) },
//     y: !{ -> CHARACTERS.y.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.y.group.move(0, -10, 0.2, EASE_IN) },
//     n: !{ -> CHARACTERS.n.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.n.group.move(0, -10, 0.2, EASE_IN) },
//     m: !{ -> CHARACTERS.m.group.move(0, 10, 0.1, EASE_OUT); -> CHARACTERS.m.group.move(0, -10, 0.2, EASE_IN) },
// }

hide_char_funcs = { // this saved 30 whole groups WHAT
    s: !{ -> CHARACTERS.s.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.s.group.alpha(0, 0.25) },
    y: !{ -> CHARACTERS.y.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.y.group.alpha(0, 0.25) },
    n: !{ -> CHARACTERS.n.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.n.group.alpha(0, 0.25) },
    m: !{ -> CHARACTERS.m.group.move(0, -5, 0.25, EASE_IN); -> CHARACTERS.m.group.alpha(0, 0.25) },
}

let transform_cached_functions = {}


//    x*0.14    // move units
//    x*0.42    // obj units
//    x = 15b   // total grid squares (blocks)

tcommon = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.14
    pos = CHARACTERS[char].pos

    cache_name = char+"_tcommon_"+@string(x_pix)+"_"+@string(CHARACTERS[char].visible)+"_"+@string(pos.y)+@string(pos.x)
    if transform_cached_functions.get(cache_name, null) == null {
        // basically if theres no changes to be made, just dont make them
        if CHARACTERS[char].visible && pos.x == x && pos.y == 50 { return }

        transform_cached_functions[cache_name] = !{
            -> CHARACTERS[char].group.move(x-pos.x, 50-pos.y, 0.25, EASE_IN)
        } if CHARACTERS[char].visible else !{
            // if the character is invisible, move to current position instantly then make it visible
            -> CHARACTERS[char].group.move(x-pos.x, 48-pos.y, 0)
            -> CHARACTERS[char].group.move(0, 2, 0.25, EASE_IN)
            -> CHARACTERS[char].group.alpha(1, 0.25) // placing it here is VERY benefic for the group and obj count, but obviously it stresses the optimizer
        }
    }

    collectable(transform_cached_functions[cache_name], 300)
    
    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 50}
}

tinstant = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.14
    pos = CHARACTERS[char].pos

    cache_name = char+"_tinstant_"+@string(x_pix)+"_"+@string(pos.y)
    if transform_cached_functions.get(cache_name, null) == null {
        if CHARACTERS[char].visible && pos.x == x { return }

        transform_cached_functions[cache_name] = !{ -> CHARACTERS[char].group.move(x-pos.x, 50-pos.y, 0) }
    }

    collectable(transform_cached_functions[cache_name], 300)

    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 50}
}

focus = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.14
    pos = CHARACTERS[char].pos

    cache_name = char+"_focus_"+@string(x_pix)+"_"+@string(CHARACTERS[char].visible)+"_"+@string(pos.y)+"_"+@string(pos.x)
    if transform_cached_functions.get(cache_name, null) == null {
        // basically if theres no changes to be made, just dont make them
        if CHARACTERS[char].visible && pos.x == x && pos.y == 53 { return }

        transform_cached_functions[cache_name] = !{
            -> CHARACTERS[char].group.move(x-pos.x, 53-pos.y, 0.25, EASE_IN)
        } if CHARACTERS[char].visible else !{
            // if the character is invisible, move to current position instantly then make it visible
            -> CHARACTERS[char].group.move(x-pos.x, 51-pos.y, 0)
            -> CHARACTERS[char].group.move(0, 2, 0.25, EASE_IN)
            -> CHARACTERS[char].group.alpha(1, 0.25) // placing it here is VERY benefic for the group and obj count
        }
    }

    collectable(transform_cached_functions[cache_name], 300)
    
    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 53}
}

sink = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.14
    pos = CHARACTERS[char].pos

    cache_name = char+"_sink_"+@string(x_pix)+"_"+@string(pos.y)
    if transform_cached_functions.get(cache_name, null) == null {
        transform_cached_functions[cache_name] = !{
            // removed `x-pos.x` in hopes of reducing group usage when i decide to optimize this
            // after optimizing this, i dont think that impacted anything lmao but im not gonna change it back either way
            -> CHARACTERS[char].group.move(0, 47-pos.y, 0.5, EASE_IN)
        }
    }

    collectable(transform_cached_functions[cache_name], 300)
    
    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 47}
} 

hop = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.14
    pos = CHARACTERS[char].pos

    // re-optimized this
    // collectable(hop_funcs[char], 300)

    cache_name = char+"_hop"
    if transform_cached_functions.get(cache_name, null) == null {
        transform_cached_functions[cache_name] = !{
            -> CHARACTERS[char].group.move(0, 6, 0.1, EASE_OUT)
            -> CHARACTERS[char].group.move(0, -6, 0.2, EASE_IN)
        }
    }

    collectable(transform_cached_functions[cache_name], 300)

    CHARACTERS[char].visible = true
} 

leftin = (char, x_pix = 640, x_off: @number = 0, y_off: @number = 0) {
    x = x_pix*0.14
    pos = CHARACTERS[char].pos

    cache_name = char+"_leftin_"+@string(x_pix)+"_"+@string(pos.y)+"_"+@string(pos.x)
    if transform_cached_functions.get(cache_name, null) == null {
        transform_cached_functions[cache_name] = !{
            -> CHARACTERS[char].group.move(-pos.x, 50-pos.y, 0)
            -> CHARACTERS[char].group.move(x, 0, 0.25, EASE_OUT)
            // why cant i see her  BECAUSE SHE WAS FUCKING INVISIBLE
            // but i finally fixed that 😇😇😇
            -> CHARACTERS[char].group.alpha(1, 0.25)
        }
    }

    collectable(transform_cached_functions[cache_name], 300)

    CHARACTERS[char].visible = true
    CHARACTERS[char].pos = {x: x, y: 50}
}

thide = (char, x_off: @number = 0, y_off: @number = 0) {
    // wont re-optimize this, not worth the max gain of 1 group/character
    // which only happens if the character doesnt thide the entire level
    collectable(hide_char_funcs[char], 300)

    CHARACTERS[char].visible = false
    CHARACTERS[char].pos = {x: CHARACTERS[char].pos.x, y: CHARACTERS[char].pos.y - 5}
}

lhide = (char, x_off: @number = 0, y_off: @number = 0) {
    pos = CHARACTERS[char].pos

    cache_name = char+"_lhide"+"_"+@string(pos.y)
    if transform_cached_functions.get(cache_name, null) == null {
        transform_cached_functions[cache_name] = !{
            // -25 + 90 because 90 is the default pos, thats apparently what i missed (i hope)
            -> CHARACTERS[char].group.move(-25-pos.x, 0, 0.25, EASE_OUT)
            -> CHARACTERS[char].group.alpha(0, 0.35)
        }
    }

    collectable(transform_cached_functions[cache_name], 300)

    CHARACTERS[char].visible = false
    CHARACTERS[char].pos = {x: -25, y: CHARACTERS[char].pos.y}
}


show_character = (tokens, x_off: @number = 0, y_off: @number = 0) {
    // show sayori 4p zorder 2 at t11 (example command thing)
    // not sure if i currently need zorder so im gonna skip that
    // TODO: wtf apparently `behind` exists as a command token and idk what it does, nvm fuck that
    // probably sets the zorder but im not fucking with that 🤣

    char_name = tokens[0] // current character's name
    char = char_name[0] // get the first letter of the character's name
    char_index = tokens.index("at") // get the index of "at"
    char_sprite = null if tokens.length < 2 || tokens[1] in ["at", "zorder", "behind"] else tokens[1] // get the current sprite name, such as "4p"

    if char_sprite != null { change_sprite(char, char_sprite, x_off, y_off) }

    // the characetr gets shown in tcommon() and focus()

    if char_index != null && char_index < tokens.length - 1 {
        transform_type = tokens[char_index + 1]
        // $.print("old ", char, " ", CHARACTERS[char].pos)
        // $.print(transform_type)
        // this is not that bad compared to old sprites.spwn
        match transform_type {
            =="t41": tcommon(char, 200, x_off, y_off),
            =="t42": tcommon(char, 493, x_off, y_off),
            =="t43": tcommon(char, 786, x_off, y_off),
            =="t44": tcommon(char, 1080, x_off, y_off),
            =="t31": tcommon(char, 240, x_off, y_off),
            =="t32": tcommon(char, 640, x_off, y_off),
            =="t33": tcommon(char, 1040, x_off, y_off),
            =="t21": tcommon(char, 400, x_off, y_off),
            =="t22": tcommon(char, 880, x_off, y_off),
            =="t11": tcommon(char, 640, x_off, y_off),

            =="i41": tinstant(char, 200, x_off, y_off),
            =="i42": tinstant(char, 493, x_off, y_off),
            =="i43": tinstant(char, 786, x_off, y_off),
            =="i44": tinstant(char, 1080, x_off, y_off),
            =="i31": tinstant(char, 240, x_off, y_off),
            =="i32": tinstant(char, 640, x_off, y_off),
            =="i33": tinstant(char, 1040, x_off, y_off),
            =="i21": tinstant(char, 400, x_off, y_off),
            =="i22": tinstant(char, 880, x_off, y_off),
            =="i11": tinstant(char, 640, x_off, y_off),

            =="f41": focus(char, 200, x_off, y_off),
            =="f42": focus(char, 493, x_off, y_off),
            =="f43": focus(char, 786, x_off, y_off),
            =="f44": focus(char, 1080, x_off, y_off),
            =="f31": focus(char, 240, x_off, y_off),
            =="f32": focus(char, 640, x_off, y_off),
            =="f33": focus(char, 1040, x_off, y_off),
            =="f21": focus(char, 400, x_off, y_off),
            =="f22": focus(char, 880, x_off, y_off),
            =="f11": focus(char, 640, x_off, y_off),

            =="s41": sink(char, 200, x_off, y_off),
            =="s42": sink(char, 493, x_off, y_off),
            =="s43": sink(char, 786, x_off, y_off),
            =="s44": sink(char, 1080, x_off, y_off),
            =="s31": sink(char, 240, x_off, y_off),
            =="s32": sink(char, 640, x_off, y_off),
            =="s33": sink(char, 1040, x_off, y_off),
            =="s21": sink(char, 400, x_off, y_off),
            =="s22": sink(char, 880, x_off, y_off),
            =="s11": sink(char, 640, x_off, y_off),

            =="h41": hop(char, 200, x_off, y_off),
            =="h42": hop(char, 493, x_off, y_off),
            =="h43": hop(char, 786, x_off, y_off),
            =="h44": hop(char, 1080, x_off, y_off),
            =="h31": hop(char, 240, x_off, y_off),
            =="h32": hop(char, 640, x_off, y_off),
            =="h33": hop(char, 1040, x_off, y_off),
            =="h21": hop(char, 400, x_off, y_off),
            =="h22": hop(char, 880, x_off, y_off),
            =="h11": hop(char, 640, x_off, y_off),

            =="l41": leftin(char, 200, x_off, y_off),
            =="l42": leftin(char, 493, x_off, y_off),
            =="l43": leftin(char, 786, x_off, y_off),
            =="l44": leftin(char, 1080, x_off, y_off),
            =="l31": leftin(char, 240, x_off, y_off),
            =="l32": leftin(char, 640, x_off, y_off),
            =="l33": leftin(char, 1040, x_off, y_off),
            =="l21": leftin(char, 400, x_off, y_off),
            =="l22": leftin(char, 880, x_off, y_off),
            =="l11": leftin(char, 640, x_off, y_off),

            =="thide": thide(char, x_off, y_off),
            =="lhide": lhide(char, x_off, y_off),
        }
        // $.print("new ", char, " ", CHARACTERS[char].pos)
    }
}

hide_character = (tokens, x_off: @number = 0, y_off: @number = 0) {
    char = tokens[0][0]
    if CHARACTERS[char].visible == false { return }

    collectable(hide_char_funcs[char], 300)

    CHARACTERS[char].visible = false
    CHARACTERS[char].pos = {x: CHARACTERS[char].pos.x, y: CHARACTERS[char].pos.y - 5}
}



python_single_line = (tokens) {
    // return if the line is not setting a variable (change later)
    if !("=" in tokens) { return }
    variable = tokens[0]
    value = tokens[2]

    // s_name = "Sayori"
    if variable.substr(1, 6) == "_name" { // if it sets someone's name
        CHARACTERS[variable[0]].name = value.replace('"', "").replace("'", "")
    }
}


let labels = {}
call_label = (label_name: @string) {
    let current_code_blocks = []
    let i_line = 0
    for line in labels[label_name] {
        [__tokens, tabs] = labels[label_name][i_line]
    
        command = __tokens[0]
        if !(command in TOKENS) && command[0] != '"' { i_line ++; continue } // if its not a valid token/word
        tokens = __tokens[1:] // remove the command bit from tokens

        if command == "return" { break }

        match command {
            in CHARACTERS_TOKENS: say_character(command, tokens, 300, 15, 169, 75),
            =="scene": set_scene(tokens, labels[label_name][i_line+1], 300, 13),
            =="show": show_character(tokens, 300, 13),
            =="hide": hide_character(tokens, 300, 13),
            =="$": python_single_line(tokens),
            =="with": with(tokens, 300, 13),
            =="call": call_label(tokens[0]),
        }
        
        // if narrator
        if command[0] == "\"" && tokens.length == 0 {
            say_narrator(command, 300, 13)
        }
    
        // doing it like this cuz u cant break in a match statement lmao
        // im gonna change this later so it just resumes instead of breaking
        if command == "call" { break }

        // $.print(modified_line)
        i_line ++
    }
}











create_scene_wiper_thing(1000, 60)
// make bg invisible
$.add(obj{
    OBJ_ID: 1007, // alpha trigger
    X: -45, Y: 369,
    TARGET: _BACKGROUNDS_GROUP,
    OPACITY: 0,
    DURATION: 0,
})

gen_crash_triggers()

// generate and add characers
for i in 0..MAIN_CHARACTERS_KEYS.length {
    // alpha = 0 at the start to hide the characters
    $.add(obj{
        OBJ_ID: 1007, // alpha trigger
        X: -45, Y: 420,
        TARGET: CHARACTERS[MAIN_CHARACTERS_KEYS[i]].group,
        OPACITY: 0,
        DURATION: 0,
    })
}


// generate and add all bgs
for bg in 0..BACKGROUNDS.length {
    // jpeg(bg+".png", 42, 0)
    _BG_GROUPS.push(@group(998 - _BG_GROUPS.length))
    image(BACKGROUND_FILE_NAMES[bg], [_BG_GROUPS[-1], _BACKGROUNDS_GROUP], 42, (_BG_GROUPS.length-1)*600, -40, -3, false)
    -> _BG_GROUPS[-1].toggle_off()
}



// move 200 move units up so we cant see the game on the main menu (lazy and bad fix ik :Rofl;) gonna change later probably
$.add(obj{
    OBJ_ID: 901, // move trigger id
    X: -40, Y: 250,
    TARGET: _SCENE_GROUP,
    MOVE_Y: 600,
    DURATION: 0,
})


// black bars
for i in 0..2 {
    for j in 0..5 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: 0 + i*600, Y: -570 + j*60,
            GROUPS: _SCENE_GROUP,
            COLOR: _RED_COLOR,
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 2.2,
            Z_ORDER: 69,
            Z_LAYER: 7,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}

// hide stuff beyond the black bars
for i in 0..2 {
    for j in 0..2 {
        for x in 0..3 {
            $.add(obj{
                OBJ_ID: 211, // white block
                X: -75 + -x*75*(1+i*-2) + i*750, Y: -525 + j*150,
                GROUPS: _SCENE_GROUP,
                COLOR: _RED_COLOR,
                HVS: "0a0a-100a0a0", // full black
                HVS_ENABLED: true,
                SCALING: 5,
                Z_ORDER: 69,
                Z_LAYER: 7,
                DONT_FADE: true,
                DONT_ENTER: true,
            })
        }
    }
}


// create the splash screens

// splash 1
image("bg/splash.png", [_SPLASH_GROUPS[0]], 35, -590, 2, draw_outline=false)
"   TEAM\nSALVATO".to_obj().with(GROUPS, [_SPLASH_GROUPS[0], _SCENE_GROUP]).with(X, 300).with(Y, -525).with(SCALING, 0.7).add()
"ported/recreated by bombie using SPWN (in GD 2.1)".to_obj().with(GROUPS, [_SPLASH_GROUPS[0], _SCENE_GROUP]).with(X, 300).with(Y, -590).with(SCALING, 0.4).add()

// splash 2
@array("This is a Doki Doki Literature Club fan game that is
not affiliated with Team Salvato. It is designed to be played
only after the official game has been completed.
You can download Doki Doki Literature Club at: http://ddlc.moe
")[:-1].join("").to_obj().with(GROUPS, [_SPLASH_GROUPS[1], _SCENE_GROUP]).with(X, 300).with(Y, -450).with(SCALING, 0.45).with(DONT_FADE, true).with(DONT_ENTER, true).add()

// add white bg on the main menu and on the normal thingy
for s in 0..3 {
    for i in 0..2 {
        for j in 0..6 {
            $.add(obj{
                OBJ_ID: 211, // white block
                X: -75 + j*150 - (s%2)*45, Y: -525 + i*150 + (s%2)*600,
                GROUPS: [_SCENE_GROUP, _WHITE_BG_GROUPS[s]],
                COLOR: _RED_COLOR,
                HVS: "0a0a100a0a0", // full white
                HVS_ENABLED: true,
                SCALING: 5,
                Z_ORDER: -3 + 10*s,
                Z_LAYER: -3 + 8*(s%2),
                DONT_FADE: true,
                DONT_ENTER: true,
            })
        }
    }
}

// hide one of the white bgs
_WHITE_BG_GROUPS[2].alpha(0, 0)

// make splash screens invisible
for i in _SPLASH_GROUPS {
    $.add(obj{
        OBJ_ID: 1007, // alpha trigger
        X: -40, Y: 275,
        TARGET: i,
        OPACITY: 0,
        DURATION: 0,
    })
}


// main menu

// side semi-circle
$.add(obj{
    OBJ_ID: 1837, // quarter circle thingy
    X: 60 - 250, Y: -450,
    COLOR: _PINK_COLOR,
    GROUPS: [_SCENE_GROUP, _MAIN_MENU_GROUPS[0]],
    ROTATION: 135,
    SCALING: 10,
    Z_ORDER: 1,
    Z_LAYER: -3,
    DONT_FADE: true,
    DONT_ENTER: true,
})
$.add(obj{
    OBJ_ID: 1835, // quarter circle outline
    X: 90 - 250, Y: -450,
    COLOR: _DARK_PINK_COLOR,
    GROUPS: [_SCENE_GROUP, _MAIN_MENU_GROUPS[0]],
    ROTATION: 135,
    SCALING: 10,
    Z_ORDER: 2,
    Z_LAYER: -3,
    DONT_FADE: true,
    DONT_ENTER: true,
})

// ddlc logo
image("gui/logo.png", [_MAIN_MENU_GROUPS[1]], 80, -270, 3, draw_outline=false, size_multi=0.4)

// main menu characters
for i in 0..MAIN_CHARACTERS_KEYS.length {
    char = "synm".split("")[i]
    y = [0, 90, 50, -125][i]
    z = [8, 4, 6, 10][i]
    size = [0.9, 0.8, 0.8, 1.35][i]
    offset = [35, 15, -16, -45][i]

    image("gui/menu_art_{}.png".fmt([char]), [_MAIN_MENU_GROUPS[2], _MAIN_MENU_GIRLS_GROUPS[i]], 200 + i*52 + offset, -1000+y, z, draw_outline=true, size_multi=size)
    
}

// main menu buttons
main_menu_buttons = "New game,Credits,Quit".split(",")
for i in 0..main_menu_buttons.length {
    main_menu_buttons[i].to_obj().with(GROUPS, [_MAIN_MENU_BUTTON_GROUPS[i], _SCENE_GROUP]).with(X, 100).with(Y, -430 - i*20).with(SCALING, 0.5).with(DONT_FADE, true).with(DONT_ENTER, true).add()
    -> _MAIN_MENU_BUTTON_GROUPS[i].alpha(0, 0)
}

// credits menu
"Credits".to_obj().with(GROUPS, [_CREDITS_MENU_GROUP, _SCENE_GROUP]).with(X, 360).with(Y, -325).with(SCALING, 0.75).with(DONT_FADE, true).with(DONT_ENTER, true).add()
@array("original DDLC creators:\nTeam Salvato
")[:-1].join("").to_obj().with(GROUPS, [_CREDITS_MENU_GROUP, _SCENE_GROUP]).with(X, 290).with(Y, -395).with(SCALING, 0.45).with(DONT_FADE, true).with(DONT_ENTER, true).add()
@array("DDLC port contributors:\nbombie\nSpecky
")[:-1].join("").to_obj().with(GROUPS, [_CREDITS_MENU_GROUP, _SCENE_GROUP]).with(X, 295).with(Y, -445).with(SCALING, 0.45).with(DONT_FADE, true).with(DONT_ENTER, true).add()
@array("moral support:\nSpecky\nggod\nDeltara\nbestgamer08\nsertdfyguhi\nkr8gz
")[:-1].join("").to_obj().with(GROUPS, [_CREDITS_MENU_GROUP, _SCENE_GROUP]).with(X, 450).with(Y, -435).with(SCALING, 0.45).with(DONT_FADE, true).with(DONT_ENTER, true).add()
@array("and last but not least, thanks to:\nthe SPWN developers and every other SPWN tester
")[:-1].join("").to_obj().with(GROUPS, [_CREDITS_MENU_GROUP, _SCENE_GROUP]).with(X, 360).with(Y, -550).with(SCALING, 0.45).with(DONT_FADE, true).with(DONT_ENTER, true).add()
-> _CREDITS_MENU_GROUP.alpha(0, 0) // hide credits at the beginning


// add mask for the transition from the main menu to the game
for i in 0..2 {
    for j in 0..6 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: -75 + j*150, Y: -525 + i*150,
            GROUPS: [_SCENE_GROUP, _BLACK_MASK_GROUP],
            COLOR: _RED_COLOR,
            HVS: "0a0a-100a0a0", // full black
            HVS_ENABLED: true,
            SCALING: 5,
            Z_ORDER: 33,
            Z_LAYER: 5,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}

// make the mask invisisble at the start
-> _BLACK_MASK_GROUP.alpha(0, 0)

// add the bg circles
for k in 0..2 {
    for i in 0..5 {
        for j in 0..18 {
            $.add(obj{
                OBJ_ID: 1841, // animated circle 
                X: -125 + j*60 + i*30 + (5*30)*k, Y: -330 - i*60 - (5*60)*k,
                SCALING: 5.25, // scale 5 is a full editor grid for this object
                COLOR: _PINK_COLOR,
                GROUPS: [_SCENE_GROUP, _MAIN_MENU_GROUPS[3], _MAIN_MENU_GROUPS[4+k]],
                Z_ORDER: -2,
                Z_LAYER: -3,
                DONT_FADE: true,
                DONT_ENTER: true,
                ANIMATION_SPEED: 0.001, // cant have numbers <0.001 in geometry dash (detroit)
            })
        }
    }
}

// circles overlay
for i in 0..2 {
    for j in 0..6 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: -75 + j*150, Y: -525 + i*150,
            GROUPS: [_SCENE_GROUP, _WHITE_BG_GROUPS[3]],
            COLOR: _RED_COLOR,
            HVS: "0a0a100a0a0", // full white
            HVS_ENABLED: true,
            SCALING: 5,
            Z_ORDER: -1,
            Z_LAYER: -3,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
    }
}

// make circles invisibel at the satrt
// average gd bug, we cant make it invisible so we need to add a white overlay lmfao
-> _WHITE_BG_GROUPS[3].alpha(1, 0)

// text for when the crash trigger doesnt work
crash_text_group = ?g
"that was supposed to crash your game".to_obj().with(GROUPS, [crash_text_group, _SCENE_GROUP]).with(X, 300).with(Y, -450).with(Z_LAYER, 7).with(Z_ORDER, -3).with(SCALING, 0.7).add()
-> crash_text_group.alpha(0, 0) // make it invisible

// "focus" overlay
for i in 0..2 {
    $.add(obj{
        OBJ_ID: 211, // white block
        X: 150+i*300, Y: -450,
        GROUPS: [_SCENE_GROUP, _FOCUS_OVERLAY_GROUP],
        COLOR: _RED_COLOR,
        HVS: "0a0a-100a0a0", // full black
        HVS_ENABLED: true,
        SCALING: 10,
        Z_ORDER: -10,
        Z_LAYER: 5,
        DONT_FADE: true,
        DONT_ENTER: true,
    })
}

// make it invis
-> _FOCUS_OVERLAY_GROUP.alpha(0, 0)

// main menu tutorial
"press the left side of the screen,
spacebar, or L1 to choose between options".to_obj().with(GROUPS, [_MAIN_MENU_TUTORIAL_GROUP, _SCENE_GROUP]).with(X, 180).with(Y, -450).with(Z_LAYER, 7).with(Z_ORDER, -3).with(SCALING, 0.45).add()

"press the right side of the screen,
the up arrow, or R1 to select the option".to_obj().with(GROUPS, [_MAIN_MENU_TUTORIAL_GROUP, _SCENE_GROUP]).with(X, 420).with(Y, -450).with(Z_LAYER, 7).with(Z_ORDER, -3).with(SCALING, 0.45).add()

"(press any button to continue)".to_obj().with(GROUPS, [_MAIN_MENU_TUTORIAL_GROUP, _SCENE_GROUP]).with(X, 300).with(Y, -520).with(Z_LAYER, 7).with(Z_ORDER, -1).with(SCALING, 0.3).add()

// dashed line
for i in 0..24+1 {
    $.add(obj{
        OBJ_ID: 1111, // no collision slab item id
        X: 300,
        Y: -600 + i*12.5,
        GROUPS: [_MAIN_MENU_TUTORIAL_GROUP, _SCENE_GROUP],
        COLOR: _HALF_OPACITY_WHITE_COLOR,
        SCALING: 0.37,
        Z_LAYER: 5,
        Z_ORDER: -2,
        ROTATION: 90,
        GLOW_DISABLED: true,
    })
}

// make the tut invis
-> _MAIN_MENU_TUTORIAL_GROUP.alpha(0, 0)

// white overlay that appears when you press a side of the screen, basically touch feedback
for j in 0..2 {
    for i in 0..2 {
        $.add(obj{
            OBJ_ID: 211, // white block
            X: 150+i*300, Y: -450+j*600,
            GROUPS: [_SCENE_GROUP, _CLICK_OVERLAY_FEEDBACK_GROUP[i]],
            COLOR: _RED_COLOR,
            HVS: "0a0a100a0a0", // full white
            HVS_ENABLED: true,
            SCALING: 10,
            Z_ORDER: 10,
            Z_LAYER: 7,
            DONT_FADE: true,
            DONT_ENTER: true,
        })
        
        // make them invisible
        -> _CLICK_OVERLAY_FEEDBACK_GROUP[i].alpha(0, 0)
    }
}

// end screen

// end screen text objects
"END".to_obj().with(GROUPS, [_SCENE_GROUP, _END_SCREEN_GROUPS[0]]).with(X, 300).with(Y, 750).with(Z_LAYER, 7).with(Z_ORDER, 1).with(SCALING, 1).add()
"(whole act comig soom)".to_obj().with(GROUPS, [_SCENE_GROUP, _END_SCREEN_GROUPS[1]]).with(X, 300).with(Y, 720).with(Z_LAYER, 7).with(Z_ORDER, 1).with(SCALING, 0.4).add()

// hide them
-> _END_SCREEN_GROUPS[0].alpha(0, 0)
-> _END_SCREEN_GROUPS[1].alpha(0, 0)

// add speed portal
$.add(obj{
    OBJ_ID: 1334, // 4x speed
    X: 150, Y: 1300,
    GROUPS: [_SCENE_GROUP, _INVISIBLE_GROUP, _END_SCREEN_GROUPS[2]],
    SCALING: 8,
})

// add rotation center
$.add(obj{
    OBJ_ID: 1,
    X: 150, Y: 1300,
    GROUPS: [_SCENE_GROUP, _INVISIBLE_GROUP, _END_SCREEN_GROUPS[3]],
    SCALING: 0.1,
})

// rotate the speed portal so it moves on the x axis, which is otherwise impossible
-> _END_SCREEN_GROUPS[2].rotate(_END_SCREEN_GROUPS[3], LEVEL_DURATION*360, LEVEL_DURATION)

// all labels, custom for loop
// let labels = {} // moved to just before call_label()
let line_idx_for_labels = 0
while line_idx_for_labels < lines.length - 1 {
    if !("label" in lines[line_idx_for_labels]) { line_idx_for_labels ++; continue }

    // we already know the line starts with "label" so we can just gen the tokens
    [__tokens, label_tabs] = generate_line_tokens(lines[line_idx_for_labels])

    if __tokens[0] != "label" { line_idx_for_labels ++; continue } // if the command isnt "label", aka if we found it in a character dialog or smth
    label_name = __tokens[1].split(":")[0] // to remove the colon that the lexer didnt remove

    if label_name in LABELS_EXCLUSION_LIST { line_idx_for_labels ++; continue }

    req_tabs = label_tabs + 1

    let labels[label_name] = []

    // check if its in the current label & pregenerate the line tokens while doing so
    let i_line = line_idx_for_labels
    for line in lines[line_idx_for_labels + 1:] { // this might be wrong
        if line.length == 0 { line_idx_for_labels ++; i_line ++; continue } // skip empty lines

        [tokens, tabs] = generate_line_tokens(line)
        if tabs < req_tabs { line_idx_for_labels = i_line; break } // not in the current label
        // if tokens[0] == "return" { break } // moved to call_label()
        labels[label_name].push([tokens, tabs])
        i_line ++
    }
    
    if label_name == "ch0_main" { call_label(label_name) }

    // switch to end screen
    temp_group = ?g
    i+=300

    // tfw the spwn optimizer doesnt allow you to use wait() macros
    spawn_trigger(!{
        -> _BACKGROUNDS_GROUP.toggle_off()
        -> _TEXT_GROUP.toggle_off()
        -> _SCENE_GROUP.move(0, -200, 0)
    }, WITH_TOKEN_WAIT_TIMES.wipeleft_scene).with(GROUPS, temp_group).with(SPAWN_TRIGGERED, true).with(MULTI_TRIGGER, true).add()

    spawn_trigger(!{
        -> _END_SCREEN_GROUPS[0].alpha(1, 1)
    }, WITH_TOKEN_WAIT_TIMES.wipeleft_scene + 1.5).with(GROUPS, temp_group).with(SPAWN_TRIGGERED, true).with(MULTI_TRIGGER, true).add()
    
    spawn_trigger(!{
        -> _END_SCREEN_GROUPS[1].alpha(1, 0.5)
    }, WITH_TOKEN_WAIT_TIMES.wipeleft_scene + 4).with(GROUPS, temp_group).with(SPAWN_TRIGGERED, true).with(MULTI_TRIGGER, true).add()

    spawn_trigger(!{
        -> _END_SCREEN_GROUPS[0].alpha(0, 0.5)
        -> _END_SCREEN_GROUPS[1].alpha(0, 0.5)
    }, WITH_TOKEN_WAIT_TIMES.wipeleft_scene + 8).with(GROUPS, temp_group).with(SPAWN_TRIGGERED, true).with(MULTI_TRIGGER, true).add()

    spawn_trigger(!{
        -> _END_SCREEN_GROUPS[2].move(0, -200, 0)
        -> _END_SCREEN_GROUPS[3].move(0, -200, 0)
    }, WITH_TOKEN_WAIT_TIMES.wipeleft_scene + 8).with(GROUPS, temp_group).with(SPAWN_TRIGGERED, true).with(MULTI_TRIGGER, true).add()

    // i have to add 2 instead of stuffing everything in one because of the optimizer lmao
    collectable(wipe_left_scene_func)
    collectable(temp_group)
}

$.add(obj{ // follow player
    OBJ_ID: 901, // move trigger id
    X: 225, Y: -135,
    TARGET: _SCENE_GROUP,
    MOVE_X: PLAYER_SPEED*30*LEVEL_DURATION, // move to player
    DURATION: LEVEL_DURATION,
})

$.add(obj{ // so the level is long enough or something
    OBJ_ID: 1,
    X: PLAYER_SPEED*30*LEVEL_DURATION, Y: -69,
})

$.add(obj{ // add invisible trigger at the start
    OBJ_ID: 1007, // alpha trigger id
    X: -31, Y: -69,
    TARGET: _INVISIBLE_GROUP,
    OPACITY: 0,
    DURATION: 0,
})



text_anim_start_group = ?g

for i in 0.._TEXT_WORD_GROUPS.length {
    $.add(obj{ // add invisible trigger
        OBJ_ID: 1007, // alpha trigger id
        X: 690, Y: 420,
        GROUPS: _TEXT_WORD_GROUPS[i],
        TARGET: _TEXT_WORD_GROUPS[i],
        SPAWN_TRIGGERED: true,
        MULTI_TRIGGER: true,
        OPACITY: 1,
        DURATION: 0.06,
    })

    if i == _TEXT_WORD_GROUPS.length - 1 { break }

    $.add(obj{
        OBJ_ID: 1268, // spawn trigger id
        X: 420, Y: 690,
        GROUPS: text_anim_start_group if i == 0 else _TEXT_WORD_GROUPS[i-1],
        TARGET: _TEXT_WORD_GROUPS[i],
        SPAWN_TRIGGERED: true,
        MULTI_TRIGGER: true,
        SPAWN_DURATION: 0.1,
    })
}


stop_text_anim = ?g
for i in _TEXT_WORD_GROUPS {
    $.add(obj{
        OBJ_ID: 1616, // stop trigger
        X: 420, Y: 420,
        TARGET: i,
        GROUPS: stop_text_anim,
        SPAWN_TRIGGERED: true,
        MULTI_TRIGGER: true,
    })
}

change_dialog = !{ // change through dialog boxes
    if in_scene_transition_counter == 0 {
        -> if text_typing_animation_active_counter == 1 {
            stop_text_anim!
            -> for i in _TEXT_WORD_GROUPS { -> i.alpha(1, 0) }
            text_typing_animation_active_counter -= 1
        } else {
            stop_text_anim!
            // i tried just setting the alpha of _TEXT_GROUP to 0 but then
            // it wouldnt want to show in the show_words func
            -> for i in _TEXT_WORD_GROUPS { -> i.alpha(0, 0) }
            -> _TEXT_GROUP.move(0, -100, 0)

            text_typing_animation_active_counter += 1
            text_anim_start_group!
        }
    }
}

close_tutorial = !{
    if tutorial_closing_counter == 0 {
        tutorial_closing_counter += 1

        -> _FOCUS_OVERLAY_GROUP.alpha(0, 0.5)
        -> _MAIN_MENU_TUTORIAL_GROUP.alpha(0, 0.5)

        wait(0.5)

        tutorial_closing_counter -= 1
        in_tutorial_counter -= 1
    }
}



generate_dialog_box()
generate_borders(302, 60)


selector_iter_counter = counter(0, bits=3)
// lmao
-> _MAIN_MENU_BUTTON_GROUPS[0].pulse(rgb8(255, 220, 234), hold=999)
-> _MAIN_MENU_BUTTON_GROUPS[1].pulse(rgb(1, 1, 1), hold=999)
-> _MAIN_MENU_BUTTON_GROUPS[2].pulse(rgb(1, 1, 1), hold=999)

click_left = !{
    -> _CLICK_OVERLAY_FEEDBACK_GROUP[0].alpha(0.15, 0)

    if in_game_counter == 1 { change_dialog! } // cant return from function early 😡😡
    else if in_tutorial_counter == 1 { close_tutorial! }
    else if in_main_menu_counter == 1 {
        // saved 1 group 💪💪💪
        match selector_iter_counter {
            ==0: () {
                -> _MAIN_MENU_BUTTON_GROUPS[0].pulse(rgb(1, 1, 1), fade_in=0.1, hold=999)
                -> _MAIN_MENU_BUTTON_GROUPS[1].pulse(rgb8(255, 220, 234), fade_in=0.1, hold=999)
            } (),
            ==1: () {
                -> _MAIN_MENU_BUTTON_GROUPS[1].pulse(rgb(1, 1, 1), fade_in=0.1, hold=999)
                -> _MAIN_MENU_BUTTON_GROUPS[2].pulse(rgb8(255, 220, 234), fade_in=0.1, hold=999)
            } (),
            ==2: () {
                -> _MAIN_MENU_BUTTON_GROUPS[2].pulse(rgb(1, 1, 1), fade_in=0.1, hold=999)
                -> _MAIN_MENU_BUTTON_GROUPS[0].pulse(rgb8(255, 220, 234), fade_in=0.1, hold=999)
            } (),
        }
        
        selector_iter_counter ++
        if selector_iter_counter == 3 { selector_iter_counter -= 3 }
    }
}

click_right = !{
    -> _CLICK_OVERLAY_FEEDBACK_GROUP[1].alpha(0.15, 0)

    if in_game_counter == 1 { change_dialog! } 
    else if in_tutorial_counter == 1 { close_tutorial! }
    else if in_main_menu_counter == 1 {
        if selector_iter_counter == 0 { // play
            in_main_menu_counter -- // false
            
            // darken the color of the button
            -> _MAIN_MENU_BUTTON_GROUPS[0].pulse(rgb8(255, 189, 225), fade_in=0.1, hold=0.1, fade_out=0.1)

            _BLACK_MASK_GROUP.alpha(1, 0.6)
            -> _SCENE_GROUP.move(0, -200, 0)
            -> _BLACK_MASK_GROUP.move(0, 200, 0)
            wait(1)
            -> _BLACK_MASK_GROUP.alpha(0, 0.6)

            wait(1)
            in_game_counter ++ // true
        } else if selector_iter_counter == 1 { // credits
            if in_credits_menu_counter == 1 {
                -> _MAIN_MENU_GROUPS[1].alpha(1, 0) // logo
                -> _MAIN_MENU_GROUPS[2].alpha(1, 0) // girls
                -> _CREDITS_MENU_GROUP.alpha(0, 0) // credits
                
                -> _MAIN_MENU_BUTTON_GROUPS[1].pulse(rgb8(255, 220, 234), fade_in=0.1, hold=999)
                in_credits_menu_counter --
            } else if in_credits_menu_counter == 0 {
                -> _MAIN_MENU_GROUPS[1].alpha(0, 0) // logo
                -> _MAIN_MENU_GROUPS[2].alpha(0, 0) // girls
                -> _CREDITS_MENU_GROUP.alpha(1, 0) // credits

                // darken the color of the button
                -> _MAIN_MENU_BUTTON_GROUPS[1].pulse(rgb8(255, 189, 225), fade_in=0.1, hold=999)

                in_credits_menu_counter ++
            }
        } else if selector_iter_counter == 2 { // quit game
            // darken the color of the button
            -> _MAIN_MENU_BUTTON_GROUPS[2].pulse(rgb8(255, 189, 225), fade_in=0.1, hold=0.1, fade_out=0.5)

            wait(0.04)

            -> () {
                wait(0.1)
                -> _FOCUS_OVERLAY_GROUP.alpha(0.3, 0.5)
                -> crash_text_group.alpha(1, 0.5)
                wait(2)
                -> _FOCUS_OVERLAY_GROUP.alpha(0, 0.5)
                -> crash_text_group.alpha(0, 0.5)
            } ()
            
            crash_func!
        }
    }
}


on(gs.button_a(), click_left)
on(gs.button_b(), click_right)

on(gs.button_a_end(), !{
    -> _CLICK_OVERLAY_FEEDBACK_GROUP[0].alpha(0, 0.12)
})

on(gs.button_b_end(), !{
    -> _CLICK_OVERLAY_FEEDBACK_GROUP[1].alpha(0, 0.12)
})


// anti-nsfw bypass or whatever lmao
-> _IMAGE_OUTLINE_GROUP.move(-1000, 0, 0)
for i in 0..MAIN_CHARACTERS_KEYS.length {
    -> CHARACTERS[MAIN_CHARACTERS_KEYS[i]].group.move(-1000*(i+2), 0, 0)
}
for i in 0.._ANTI_NSFW_BYPASS_GROUPS.length {
    -> _ANTI_NSFW_BYPASS_GROUPS[i].move(-5000-1000*i, 0, 0)
}


$.writefile("./req_images.txt", @string(added_images).replace("'", '"'))
if CACHE_IMAGES { $.writefile("./cache_output.txt", "{"+cached_images.map((k, v) => '"'+k+"\": \""+v+'"').join(", ")+"}") }
$.print("words: ", words)



// runtime from now on i guess

// splash screen
wait(0.5)
-> _WHITE_BG_GROUPS[1].alpha(0, 0) // hide the white bg used to hide the game at the start
-> _SPLASH_GROUPS[0].alpha(1, 0.25)
wait(1.25)
-> _SPLASH_GROUPS[0].alpha(0, 0.25)
wait(0.75)
-> _SPLASH_GROUPS[1].alpha(1, 0.25)
wait(3.25)
-> _SPLASH_GROUPS[1].alpha(0, 0.25)


// main menu

wait(0.5)
-> for i in 0..main_menu_buttons.length { -> _MAIN_MENU_BUTTON_GROUPS[i].alpha(1, 0.25) }
-> _WHITE_BG_GROUPS[3].alpha(0, 0.25)
-> _MAIN_MENU_GROUPS[3].move(-5*LEVEL_DURATION, 5*LEVEL_DURATION, LEVEL_DURATION)
// could be better but it fucking works :shrug::shrug::shrug:
-> while_loop(() => true, () { _MAIN_MENU_GROUPS[4].move(200, -200, 0); wait(20); _MAIN_MENU_GROUPS[5].move(200, -200, 0) }, 20)
wait(0.5)   
-> _SCENE_GROUP.alpha(0, 0)
-> _SCENE_GROUP.alpha(1, 0.3)
-> _MAIN_MENU_GROUPS[0].move(250/3, 0, 1.5, EXPONENTIAL_OUT)
-> _MAIN_MENU_GROUPS[1].move(0, -45, 2, BOUNCE_OUT)
wait(0.2)
-> _MAIN_MENU_GROUPS[2].move(0, 120, 2.5, EXPONENTIAL_OUT)
-> _MAIN_MENU_GROUPS[3].move(0, 75, 3, EXPONENTIAL_OUT)

// spread out the girls (😳)
-> _MAIN_MENU_GIRLS_GROUPS[0].move(-35/3, 0, 2, EXPONENTIAL_OUT)
-> _MAIN_MENU_GIRLS_GROUPS[1].move(-15/3, 0, 2, EXPONENTIAL_OUT)
-> _MAIN_MENU_GIRLS_GROUPS[2].move(15/3, 0, 2, EXPONENTIAL_OUT)
-> _MAIN_MENU_GIRLS_GROUPS[3].move(35/3, 0, 2, EXPONENTIAL_OUT)

// tutorial
-> () {
    wait(1.5)
    -> _FOCUS_OVERLAY_GROUP.alpha(0.4, 0.4)
    -> _MAIN_MENU_TUTORIAL_GROUP.alpha(1, 0.8)

    wait(1)

    in_main_menu_counter += 1 // true
    in_tutorial_counter += 1 // true
} ()

// the part where it flashes white synced to the song, hopefully
wait(0.93)
-> _WHITE_BG_GROUPS[2].alpha(0.5, 0)
-> _WHITE_BG_GROUPS[2].alpha(0, 0.5)
-> _MAIN_MENU_GROUPS[3].move(0, -80, 0) // move the circles where they should be